= CI/CD and Automation

== Module goals
* Trigger build-time violations for images and deployments on the command line and CI/CD pipelines
* Enforce a container image vulnerability violation at build time
* Codify an image vulnerability violation enforcement in a pipeline
* Explore warnings about deployment attributes from the command line


== Implementing Security Checks into your CI/CD pipeline

Implementing CI/CD security in container builds involves more than just securing your contianer images and your deployment manifests. There are several best practices to ensure that your containerized applications are secure throughout the development and deployment lifecycle.

* Access Control: Use strong authentication and authorization mechanisms. Implement role-based access control (RBAC) to limit who can modify the pipeline and deploy applications.
* Audit Logging: Enable and regularly review audit logs to monitor access and changes to the CI/CD pipeline.
* Official and Verified Images: Always start with official images from trusted sources (e.g., Docker Hub, Red Hat, Ubuntu).
* Minimal Base Images: Use minimal base images to reduce the attack surface (e.g., alpine).
* Static Analysis: Integrate static code analysis tools (e.g., SonarQube, Snyk) into the pipeline to detect vulnerabilities in the code.
* Image Scanning: Use tools like Clair, Anchore, or Trivy to scan container images for known vulnerabilities before deploying them.
* Pin Dependencies: Specify exact versions of dependencies to avoid introducing unverified or vulnerable components.
* Regular Updates: Keep dependencies and base images updated to their latest versions to benefit from security patches.
* Environment Variables: Avoid hardcoding secrets in the source code. Use environment variables or secret management tools.
* Secret Management Tools: Use tools like HashiCorp Vault, AWS Secrets Manager, or Kubernetes Secrets to securely manage and inject secrets.
* Policy as Code: Use tools like Open Policy Agent (OPA) to define and enforce security policies as code within your CI/CD pipeline.
* Compliance Checks: Automate compliance checks to ensure all deployments adhere to security standards and policies.

Now, RHACS can be implemented into any CI/CD process as a step in the build-deploy-run lifecycle. RHACS is able to acheive this through the *roxctl CLI* and the *admission controller*. RHACS can implement those image scanning, env variables and compliance checks into those pipelines.  

Let's take a look at a very simple CI/CD pipeline in OpenShift would look like.

== Review a basic CI/CD pipeline

In this section, we will review a simple pipeline that has been configured in Red Hat^(R)^ OpenShift Pipelines. 

Red Hat^(R)^ OpenShift Pipelines is a Kubernetes-native CI/CD (Continuous Integration/Continuous Deployment) solution that automates the process of building, testing, and deploying applications. It leverages Tekton, a powerful and flexible open-source framework, to create cloud-native pipelines that integrate seamlessly with OpenShift and other Kubernetes environments. This enables developers to define and manage their build and deployment workflows as code, ensuring consistency, scalability, and repeatability across the software development lifecycle.

.Procedure
.Head over to the OpenShift Console. If you don't have access follow the steps below. If you do proceed to the following section.

==== Access the Red Hat^(R)^ OpenShift Container Platform (OCP) web console 

First, make sure you can access the Red Hat^(R)^ OCP console web console.

*Procedure*

[start=1]
. Log into the OCP console at `{web_console_url}`
. Click the *rhsso* option
. Enter the OCP credentials 

[cols="1,1"]
|===
*User:*| {openshift_admin_user} |
*Password:*| {openshift_admin_password} |
|===

image::01-ocp-login-admin.png[OpenShift console]

[start=4]
. Enter the OpenShift username *{openshift_admin_user}* and password: *{openshift_admin_password}*

image::01-ocp-login-password.png[OpenShift console login]


*Procedure Cont'd*

|====
You should be directed to the RHACM dashboard. RHACM is intergrated into the OpenShift dashboard.
|====

[start=5]
. To get to your clusters local OpenShift dashboard click the top dropdown and select *local-cluster*

image::06-cd-1.png[link=self, window=blank, width=100%]
image::06-cd-2.png[link=self, window=blank, width=100%]

[start=6]
. Click on the *Pipelines* tab on the left side of the page and select "*Pipelines*" 

image::06-cd-3.png[link=self, window=blank, width=100%]

|====
You should see all of the default pipelines that Red Hat OpenShift and it's operators use to update or fetch information. Most of these have not been run and are simply configuration files. 
|====

[start=7]
. The pipeline we are looking for is called *rox-pipeline* and you can either find it and select it or you can change the *Project to "pipeline-demo"*.

image::06-cd-4.png[link=self, window=blank, width=100%]

We haven't run the pipeline yet so let's start one.

[start=8]
. Click the three dots on the right side of the screen and select *start*

image::06-cd-5.png[link=self, window=blank, width=100%]

|====
This pipeline works by taking and image that you have created and passing it through a "roxctl image scan" and a "roxctl image check" process.
|====

[start=9]
. Let's use the *docker.io/library/rhel* image that we used in the previous module.

image::06-cd-6.png[link=self, window=blank, width=100%]

IMPORTANT: The pipeline should fail. 

|====
Why do you think the pipeline failed?
|====

Let's look at the logs.

[start=10]
. Take a look at the log snippet on the bottom right of the page.

image::06-cd-9.png[link=self, window=blank, width=100%]

*Sample output*
[source,bash]
----
curl: (6) Could not resolve host: ROX_CENTRAL_ENDPOINT
Getting roxctl
chmod: cannot access './roxctl': No such file or directory
/tekton/scripts/script-0-ftdft: line 5: ./roxctl: No such file or directory
----

This snippet is talling us that that are variable that are incorrect. With RHACS you will need API access to query central for results. 

Let's take a look at the secret file necessary for *OpenShift Pipelines*.

[start=11]
. Run the following in the terminal.

[source,sh,subs="attributes",role=execute]
----
export TUTORIAL_HOME="$(pwd)/demo-apps"
ls $TUTORIAL_HOME/openshift-pipelines
----

*Sample output*
[source,bash]
----
[lab-user@bastion pipeline]$ ls $TUTORIAL_HOME/openshift-pipelines
pipeline  secrets  tasks
----

As you can see, the pipelines are broken up into one pipeline, with three tasks that need a secret file. Let's take a look at what variables are needed for the pipeline.

[start=12]
. Run the following in the terminal.

[source,sh,subs="attributes",role=execute]
----
cat $TUTORIAL_HOME/openshift-pipelines/secrets/rox-secrets.yml
----

*Sample output*
[source,bash]
----
[lab-user@bastion pipeline]$ ls $TUTORIAL_HOME/openshift-pipelines
pipeline  secrets  tasks
----

== Enforce Container Image Vulnerability Violation at Build Time

In this section, you configure the proper policies for enforcement, test them on the command line, and then execute them via Pipelines.

=== Configure RHACS Policy

.Procedure
. From the left navigation menu, select *Platform Configuration -> Policy Management*.
. Scroll down to `Fixable CVSS >= 7` (`rhacs_fix_image_vuln_policy`):
+
image::08_build_00.png[RHACS Policy - Configure]
+
TIP: You can find this policy quickly by entering `fixable` in the filter bar at the top of the page.
+
You can see that the `Fixable CVSS >= 7` policy has both the `Build` and `Deploy` lifecycles set as `Enabled: No`.
RHACS can detect the presence of this vulnerability in images at both stages.
But it is not yet enabled, and is not yet enforcing.
The next steps are to edit the policy to enable and enforce it.

. Review the other attributes, and note the `Rationale` and `Guidance` fields, which you can expect to see in the policy output later.
. Click the `Actions` drop down and enable the policy.
. You can also edit the policy and preview oputcomes before accept any changes to the policy.

=== Codify Image Vulnerability Violation Enforcement in Pipeline

When incorporated into a CI/CD build pipeline, this failure code stops the pipeline and leaves the policy violation output in the build job console.

.Procedure
. Navigate to your OpenShift web console, and on the left navigation menu select *Pipelines -> Pipelines*:
+
image::rhacs_pipeline_pipelines.png[RHACS - OpenShift Console Pipelines]
+
NOTE: You can find your OpenShift Console URL and credentials in your Red Hat provisioning email message.

. Click `rox-pipeline` to rerun the failed `rox-pipeline` pipeline with the container image you tested earlier from the command line.
+
. From this *Pipeline details* page, use the *Actions* menu to select *Start*:
+
image::rhacs_pipeline_start.png[RHACS Pipeline Start]
+
. In the window that appears, paste the container image URL (`docker.io/vulnerables/cve-2017-7494`) and click *Start*:
+
image::rhacs_pipeline_failed_docker.png[RHACS PipelineRun TaskRun failure]
+
This PipelineRun kicked off a TaskRun to run the `image-check` task.
It failed the same way it failed on the `stackrox` command line earlier.
Only this time, it is part of a pipeline and causes a build failure.

. Click the *Logs* tab to see the full output of the `image-check` failure.
+
NOTE: Because vulnerability changes often, your output results for the particular CVEs in this image may vary.
The output is truncated for increased readability.

////
rhacs_pipeline_taskRun_no_bash_enforce_OFF.png
rhacs_pipeline_taskRun_no_bash.png
rhacs_pipeline_pipelineRun_failed_CVE7.png
image::rhacs_pipeline_rerun.png[RHACS PipelineRun Rerun]
////

== Warn About Deployment Attributes at Build Time

In this section, you explore RHACS's visibility and control over Kubernetes deployment attributes at build time--before an application is deployed--shortening the time to discover and correct workflow and configuration errors.

Kubernetes deployments are defined in YAML and declare the desired state of the application and all of its components.
Among the many supported attributes are privilege levels, secrets access, storage requirements, and, as illustrated in this next section, network service exposure.

=== Test Warnings About Deployment Attributes from Command Line

This simple YAML file declares an example deployment from a public image, and attempts to expose the service on that deployment on TCP port 22, typically reserved for SSH.

.Procedure
. On your student VM, create the `$HOME/deployment.yaml` file:
+
[source,sh]
----
cat << EOF >$HOME/deployment.yaml
apiVersion: v1
kind: Service
metadata:
  name: ubuntu-lb
  labels:
    app: ubuntu
spec:
  ports:
    - port: 22
  selector:
    app: ubuntu
  type: LoadBalancer
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ubuntu
  labels:
    app: ubuntu
spec:
  selector:
    matchLabels:
      app: ubuntu
  template:
    metadata:
      labels:
        app: ubuntu
    spec:
      containers:
      - name: ubuntu
        image: ubuntu:18.04
        ports:
        - containerPort: 22
EOF
----

. Use `roxctl` to run a check on the YAML code using the `--file` argument:
+
[source,sh]
----
roxctl -e $CENTRAL:443 deployment check --file deployment.yaml --insecure-skip-tls-verify
----
+
.Sample Output
[source,texinfo,options="nowrap"]
----
Policy check results for deployments: [ubuntu]
(TOTAL: 5, LOW: 2, MEDIUM: 2, HIGH: 1, CRITICAL: 0)

+--------------------------------+----------+---------------+------------+--------------------------------+--------------------------------+--------------------------------+
|             POLICY             | SEVERITY | BREAKS DEPLOY | DEPLOYMENT |          DESCRIPTION           |           VIOLATION            |          REMEDIATION           |
+--------------------------------+----------+---------------+------------+--------------------------------+--------------------------------+--------------------------------+
|    Secure Shell (ssh) Port     |   HIGH   |       -       |   ubuntu   | Alert on deployments exposing  |    - Exposed port 22/TCP is    |  Ensure that non-SSH services  |
|            Exposed             |          |               |            | port 22, commonly reserved for |            present             | are not using port 22. Ensure  |
|                                |          |               |            |          SSH access.           |                                |  that any actual SSH servers   |
|                                |          |               |            |                                |                                |       have been vetted.        |
+--------------------------------+----------+---------------+------------+--------------------------------+--------------------------------+--------------------------------+
| No resource requests or limits |  MEDIUM  |       -       |   ubuntu   | Alert on deployments that have | - CPU limit set to 0 cores for |    Specify the requests and    |
|           specified            |          |               |            |  containers without resource   |       container 'ubuntu'       |  limits of CPU and Memory for  |
|                                |          |               |            |      requests and limits       |                                |        your deployment.        |
|                                |          |               |            |                                |  - CPU request set to 0 cores  |                                |
|                                |          |               |            |                                |     for container 'ubuntu'     |                                |
|                                |          |               |            |                                |                                |                                |
|                                |          |               |            |                                | - Memory limit set to 0 MB for |                                |
|                                |          |               |            |                                |       container 'ubuntu'       |                                |
|                                |          |               |            |                                |                                |                                |
|                                |          |               |            |                                |  - Memory request set to 0 MB  |                                |
|                                |          |               |            |                                |     for container 'ubuntu'     |                                |
+--------------------------------+----------+---------------+------------+--------------------------------+--------------------------------+--------------------------------+
|   Pod Service Account Token    |  MEDIUM  |       -       |   ubuntu   |  Protect pod default service   |    - Deployment mounts the     |              Add               |
|     Automatically Mounted      |          |               |            | account tokens from compromise |    service account tokens.     | `automountServiceAccountToken: |
|                                |          |               |            |   by minimizing the mounting   |                                |   false` or a value distinct   |
|                                |          |               |            |     of the default service     | - Namespace has name 'default' |     from 'default' for the     |
|                                |          |               |            |  account token to only those   |                                |    `serviceAccountName` key    |
|                                |          |               |            |     pods whose application     |  - Service Account is set to   |    to the deployment's Pod     |
|                                |          |               |            | requires interaction with the  |           'default'            |         configuration.         |
|                                |          |               |            |        Kubernetes API.         |                                |                                |
+--------------------------------+----------+---------------+------------+--------------------------------+--------------------------------+--------------------------------+
|  Docker CIS 4.1: Ensure That   |   LOW    |       -       |   ubuntu   |   Containers should run as a   | - Container 'ubuntu' has image | Ensure that the Dockerfile for |
|  a User for the Container Has  |          |               |            |         non-root user          |        with user 'root'        |  each container switches from  |
|          Been Created          |          |               |            |                                |                                |         the root user          |
+--------------------------------+----------+---------------+------------+--------------------------------+--------------------------------+--------------------------------+
|   Ubuntu Package Manager in    |   LOW    |       -       |   ubuntu   |      Alert on deployments      | - Container 'ubuntu' includes  |    Run `dpkg -r --force-all    |
|             Image              |          |               |            |     with components of the     |    component 'apt' (version    |     apt apt-get && dpkg -r     |
|                                |          |               |            |     Debian/Ubuntu package      |            1.6.14)             |  --force-all debconf dpkg` in  |
|                                |          |               |            |    management system in the    |                                | the image build for production |
|                                |          |               |            |             image.             | - Container 'ubuntu' includes  |          containers.           |
|                                |          |               |            |                                |   component 'dpkg' (version    |                                |
|                                |          |               |            |                                |       1.19.0.5ubuntu2.3)       |                                |
+--------------------------------+----------+---------------+------------+--------------------------------+--------------------------------+--------------------------------+
WARN:	A total of 5 policies have been violated
----
+
The warning is clear, and the policy was enforced.
In the next section, you try it as part of a build pipeline.

=== Warn About Deployment Attributes at Build Time from Pipeline

RHACS does not check only images from pipelines--it can also check the deployment and service manifests.
In the pipeline provided in this lab, you can paste the base64-encoded manifests into the UI and verify them.
This is just a simple, focused example.
In a complete pipeline integration, these manifests are not delivered by hand as base64, but checked out of a source code control system such as Git by means of dedicated Tekton Pipeline tasks.

.Procedure
. Navigate to your OpenShift web console, and select *Pipelines -> Pipelines* from the left navigation menu:
+
image::rhacs_pipeline_pipelines.png[RHACS - OpenShift Console Pipelines]
+
NOTE: You can find your OpenShift Console URL and credentials in your Red Hat provisioning email message.

. Select `rox-deploy-pipeline` to run this pipeline with the container image you tested earlier from the command line.
+
IMPORTANT: This pipeline is named `rox-deploy-pipeline`.
Do not confuse it with the prior pipeline `rox-pipeline`, which only verifies images.

. From this *Pipeline details* page, use the *Actions* menu to select *Start*:
+
image::rhacs_pipeline_start_check_deploy.png[RHACS Pipeline Start Check Deploy]

. In the window that appears, provide three required parameters:
.. In the *Parameters yaml* field, paste the following data, which is the base64-encoded representation of the manifests that you created earlier:
+
[source,texinfo]
----
YXBpVmVyc2lvbjogdjEKa2luZDogU2VydmljZQptZXRhZGF0YToKICBuYW1lOiB1YnVudHUtbGIKICBsYWJlbHM6CiAgICBhcHA6IHVidW50dQpzcGVjOgogIHBvcnRzOgogICAgLSBwb3J0OiAyMgogIHNlbGVjdG9yOgogICAgYXBwOiB1YnVudHUKICB0eXBlOiBMb2FkQmFsYW5jZXIKLS0tCmFwaVZlcnNpb246IGFwcHMvdjEKa2luZDogRGVwbG95bWVudAptZXRhZGF0YToKICBuYW1lOiB1YnVudHUKICBsYWJlbHM6CiAgICBhcHA6IHVidW50dQpzcGVjOgogIHNlbGVjdG9yOgogICAgbWF0Y2hMYWJlbHM6CiAgICAgIGFwcDogdWJ1bnR1CiAgdGVtcGxhdGU6CiAgICBtZXRhZGF0YToKICAgICAgbGFiZWxzOgogICAgICAgIGFwcDogdWJ1bnR1CiAgICBzcGVjOgogICAgICBjb250YWluZXJzOgogICAgICAtIG5hbWU6IHVidW50dQogICAgICAgIGltYWdlOiB1YnVudHU6MTguMDQKICAgICAgICBwb3J0czoKICAgICAgICAtIGNvbnRhaW5lclBvcnQ6IDIyCgo=
----
+
.. For *Workspaces* -> *files*, select `PersistentVolumeClaim`.
.. For *Select a PVC*, select the first PVC.
(PVCs can be reused, because the data is overwritten to the same file inside the PV each time.)
+
This PipelineRun kicked off two TaskRuns:
+
* The first, `write-yaml`, decoded the base64 and wrote it to the PV as `/deployfile/deploy.yaml`.
* The second, `deploy-check`, actually ran `stackrox` against the file.
+
NOTE: This PipelineRun only generated a warning. This is the same way you received a warning on the `stackrox` command line earlier, but this time it is part of a pipeline.

. Examine the *PipelineRun details* page and note that because there were no enforced policies, you do not see any failures or log snippets.

. Click the *Logs* tab to see the full output of the `deploy-check` failure:
+
image::rhacs_pipeline_deployment_warning_log.png[RHACS Deployment Check Warning]

////
If you'd like to investigate the `write-yaml` Task, it's implemented like this:
----
     script: |
        #!/usr/bin/env bash
        echo "$(params.yaml)" | base64 -d > /deployfile/deploy.yml
----
////

== Summary

In this lab, you became familiar with how to prevent vulnerabilities from reaching production by triggering build-time violations for images and deployments on the command line and CI/CD pipelines.
